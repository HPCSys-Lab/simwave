@kernel void stencil(const long stencil_radius, const long nz, const long nx, const long domain_size,
                     const long prev_t, const long current_t, const long next_t,
                     const double dzSquared, const double dxSquared, const double dtSquared, const double dt,
                     double *u, const double *velocity, const double *coeff, const double *damp
                     ){
    
    for(long i = stencil_radius; i < nz - stencil_radius; i++; @outer) {
        for(long j = stencil_radius; j < nx - stencil_radius; j++; @inner) {
            // index of the current polong in the grid
            long domain_offset = i * nx + j;

            long prev_snapshot = prev_t * domain_size + domain_offset;
            long current_snapshot = current_t * domain_size + domain_offset;
            long next_snapshot = next_t * domain_size + domain_offset;

            // stencil code to update grid
            double value = 0.0;

            double sum_x = coeff[0] * u[current_snapshot];
            double sum_z = coeff[0] * u[current_snapshot];
            
            for(long ir = 1; ir <= stencil_radius; ir++){
                //neighbors in the horizontal direction
                sum_x += coeff[ir] * (u[current_snapshot + ir] + u[current_snapshot - ir]);

                //neighbors in the vertical direction
                sum_z += coeff[ir] * (u[current_snapshot + (ir * nx)] + u[current_snapshot - (ir * nx)]);
            }

            value += sum_x/dxSquared + sum_z/dzSquared;

            //denominator with damp coefficient
            double denominator = (1.0 + damp[domain_offset] * dt);

            value *= (dtSquared * velocity[domain_offset] * velocity[domain_offset]) / denominator;

            u[next_snapshot] = 2.0 / denominator * u[current_snapshot] - ((1.0 - damp[domain_offset] * dt) / denominator) * u[prev_snapshot] + value;
        }
    }

}