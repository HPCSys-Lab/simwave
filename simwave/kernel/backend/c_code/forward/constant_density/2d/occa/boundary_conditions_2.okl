@kernel void boundary_conditions_2(const long stencil_radius, const long nz, const long nx,
                                   const long z_before, const long z_after, const long next_t, const long domain_size,
                                   double *u 
                                  ){
    
    for(long j = stencil_radius; j < nx - stencil_radius; j++; @tile(1, @outer, @inner)){

        // null dirichlet on the top
        if(z_before == 1){
            long domain_offset = stencil_radius * nx + j;
            long next_snapshot = next_t * domain_size + domain_offset;
            u[next_snapshot] = 0.0;
        }

        // null neumann on the top
        if(z_before == 2){                
            for(long ir = 1; ir <= stencil_radius; ir++){
                long domain_offset = stencil_radius * nx + j;
                long next_snapshot = next_t * domain_size + domain_offset;
                u[next_snapshot - (ir * nx)] = u[next_snapshot + (ir * nx)];
            }
        }

        // null dirichlet on the bottom
        if(z_after == 1){
            long domain_offset = (nz - stencil_radius - 1) * nx + j;
            long next_snapshot = next_t * domain_size + domain_offset;
            u[next_snapshot] = 0.0;
        }

        // null neumann on the bottom
        if(z_after == 2){
            for(long ir = 1; ir <= stencil_radius; ir++){
                long domain_offset = (nz - stencil_radius - 1) * nx + j;
                long next_snapshot = next_t * domain_size + domain_offset;
                u[next_snapshot + (ir * nx)] = u[next_snapshot - (ir * nx)];
            }
        }

    }
}