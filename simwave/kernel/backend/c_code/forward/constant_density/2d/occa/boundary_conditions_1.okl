@kernel void boundary_conditions_1(const long stencil_radius, const long nz, const long nx,
                                   const long x_before, const long x_after, const long next_t, const long domain_size,
                                   double *u 
                                  ){
    
    // boundary conditions on the left and right (fixed in X)
    for(long i = stencil_radius; i < nz - stencil_radius; i++; @tile(1, @outer, @inner)){

        // null dirichlet on the left
        if(x_before == 1){
            long domain_offset = i * nx + stencil_radius;
            long next_snapshot = next_t * domain_size + domain_offset;
            u[next_snapshot] = 0.0;
        }

        // null neumann on the left
        if(x_before == 2){
            
            for(long ir = 1; ir <= stencil_radius; ir++){
                long domain_offset = i * nx + stencil_radius;
                long next_snapshot = next_t * domain_size + domain_offset;
                u[next_snapshot - ir] = u[next_snapshot + ir];
            }
        }

        // null dirichlet on the right
        if(x_after == 1){
            long domain_offset = i * nx + (nx - stencil_radius - 1);
            long next_snapshot = next_t * domain_size + domain_offset;
            u[next_snapshot] = 0.0;
        }

        // null neumann on the right
        if(x_after == 2){
            
            for(long ir = 1; ir <= stencil_radius; ir++){
                long domain_offset = i * nx + (nx - stencil_radius - 1);
                long next_snapshot = next_t * domain_size + domain_offset;
                u[next_snapshot + ir] = u[next_snapshot - ir];
            }
        }

    }

}