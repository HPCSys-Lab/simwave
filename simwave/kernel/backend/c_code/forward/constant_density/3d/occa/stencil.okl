@kernel void stencil(const int stencil_radius, const int nz, const int nx, const int ny, const int domain_size,
                     const int prev_t, const int current_t, const int next_t,
                     const double dzSquared, const double dxSquared, const double dySquared, const double dtSquared, const double dt,
                     double *u, const double *velocity, const double *coeff, const double *damp
                     ){

    for(int i = stencil_radius; i < nz - stencil_radius; i++; @tile(BLOCK_SIZE_Z, @outer, @inner)) {
        for(int j = stencil_radius; j < nx - stencil_radius; j++;  @tile(BLOCK_SIZE_X, @outer, @inner)) {
            for(int k = stencil_radius; k < ny - stencil_radius; k++;  @tile(BLOCK_SIZE_Y, @outer, @inner)) {
                // index of the current point in the grid
                int domain_offset = (i * nx + j) * ny + k;

                int prev_snapshot = prev_t * domain_size + domain_offset;
                int current_snapshot = current_t * domain_size + domain_offset;
                int next_snapshot = next_t * domain_size + domain_offset;

                // stencil code to update grid
                double value = 0.0;

                double sum_y = coeff[0] * u[current_snapshot];
                double sum_x = coeff[0] * u[current_snapshot];
                double sum_z = coeff[0] * u[current_snapshot];

                // radius of the stencil
                #ifdef GPU_OPENACC
                #pragma acc loop seq
                #endif
                for(int ir = 1; ir <= stencil_radius; ir++){
                    //neighbors in the Y direction
                    sum_y += coeff[ir] * (u[current_snapshot + ir] + u[current_snapshot - ir]);

                    //neighbors in the X direction
                    sum_x += coeff[ir] * (u[current_snapshot + (ir * ny)] + u[current_snapshot - (ir * ny)]);

                    //neighbors in the Z direction
                    sum_z += coeff[ir] * (u[current_snapshot + (ir * nx * ny)] + u[current_snapshot - (ir * nx * ny)]);
                }

                value += sum_y/dySquared + sum_x/dxSquared + sum_z/dzSquared;

                //nominator with damp coefficient
                double denominator = (1.0 + damp[domain_offset] * dt);

                value *= (dtSquared * velocity[domain_offset] * velocity[domain_offset]) / denominator;

                u[next_snapshot] = 2.0 / denominator * u[current_snapshot] - ((1.0 - damp[domain_offset] * dt) / denominator) * u[prev_snapshot] + value;
            }
        }
    }
}
