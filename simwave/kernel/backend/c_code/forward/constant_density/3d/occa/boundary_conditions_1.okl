@kernel void boundary_conditions_1(const int stencil_radius, const int nz, const int nx, const int ny,
                                   const int y_before, const int y_after, const int next_t, const int domain_size,
                                   double *u 
                                  ){    
    
    for(int i = stencil_radius; i < nz - stencil_radius; i++; @tile(BLOCK_SIZE_Z, @outer, @inner)){
        for(int j = stencil_radius; j < nx - stencil_radius; j++; @tile(BLOCK_SIZE_X, @outer, @inner)){

            // null dirichlet on the left
            if(y_before == 1){
                int domain_offset = (i * nx + j) * ny + stencil_radius;
                int next_snapshot = next_t * domain_size + domain_offset;
                u[next_snapshot] = 0.0;
            }

            // null neumann on the left
            if(y_before == 2){                
                for(int ir = 1; ir <= stencil_radius; ir++){
                    int domain_offset = (i * nx + j) * ny + stencil_radius;
                    int next_snapshot = next_t * domain_size + domain_offset;
                    u[next_snapshot - ir] = u[next_snapshot + ir];
                }
            }

            // null dirichlet on the right
            if(y_after == 1){
                int domain_offset = (i * nx + j) * ny + (ny - stencil_radius - 1);
                int next_snapshot = next_t * domain_size + domain_offset;
                u[next_snapshot] = 0.0;
            }

            // null neumann on the right
            if(y_after == 2){                
                for(int ir = 1; ir <= stencil_radius; ir++){
                    int domain_offset = (i * nx + j) * ny + (ny - stencil_radius - 1);
                    int next_snapshot = next_t * domain_size + domain_offset;
                    u[next_snapshot + ir] = u[next_snapshot - ir];
                }
            }

        }
    }
}