@kernel void source_injection(const int num_sources, const int n, const int wavelet_count, const int next_t, const int nx, const int ny, const int domain_size,
                              const double dtSquared,
                              const double *wavelet, const long *src_points_interval, const long *src_points_values_offset, const double *src_points_values,
                              const double *velocity, double *u
                             ){    

    // for each source
    for(int src = 0; src < num_sources; src++; @tile(1, @outer, @inner)){

        int wavelet_offset = n - 1;

        if(wavelet_count > 1){
            wavelet_offset = (n-1) * num_sources + src;
        }

        if(wavelet[wavelet_offset] != 0.0){

            // each source has 6 (z_b, z_e, x_b, x_e, y_b, y_e) point intervals
            int offset_src = src * 6;

            // interval of grid points of the source in the Z axis
            int src_z_begin = src_points_interval[offset_src + 0];
            int src_z_end = src_points_interval[offset_src + 1];

            // interval of grid points of the source in the X axis
            int src_x_begin = src_points_interval[offset_src + 2];
            int src_x_end = src_points_interval[offset_src + 3];

            // interval of grid points of the source in the Y axis
            int src_y_begin = src_points_interval[offset_src + 4];
            int src_y_end = src_points_interval[offset_src + 5];

            // number of grid points of the source in each axis
            int src_z_num_points = src_z_end - src_z_begin + 1;
            int src_x_num_points = src_x_end - src_x_begin + 1;
            
            // pointer to src value offset
            int offset_src_kws_index_z = src_points_values_offset[src];

            // index of the Kaiser windowed sinc value of the source point
            int kws_index_z = offset_src_kws_index_z;

            // for each source point in the Z axis                
            for(int i = src_z_begin; i <= src_z_end; i++){
                int kws_index_x = offset_src_kws_index_z + src_z_num_points;

                // for each source point in the X axis                    
                for(int j = src_x_begin; j <= src_x_end; j++){

                    int kws_index_y = offset_src_kws_index_z + src_z_num_points + src_x_num_points;

                    // for each source point in the Y axis                        
                    for(int k = src_y_begin; k <= src_y_end; k++){

                        double kws = src_points_values[kws_index_z] * src_points_values[kws_index_x] * src_points_values[kws_index_y];

                        // current source point in the grid
                        int domain_offset = (i * nx + j) * ny + k;
                        int next_snapshot = next_t * domain_size + domain_offset;

                        double value = dtSquared * velocity[domain_offset] * velocity[domain_offset] * kws * wavelet[wavelet_offset];

                        @atomic{
                            u[next_snapshot] += value;
                        }
                        

                        kws_index_y++;
                    }
                    kws_index_x++;
                }
                kws_index_z++;
            }
        }
    }
}